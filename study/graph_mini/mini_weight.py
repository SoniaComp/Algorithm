# 최단 경로 문제
# 시작 정점에서 목표 정점까지 가는 간선의 가중치의 합이 최소가 되는 경로를 찾는 문제

# 단일 시작접 최단 경로 문제
# 출발접에서 다른 모든 정점들에 이르는 최단 경로를 구하는 문제
# 다익스트라알고리즘: 음의 가중치 허용하지 않음
# 벨만포트 알고리즘: 음의 가중치 허용하지만 가중치 합이 음인 사이클은 허용하지 않음

# 모든 쌍 최단 경로 문제
# 모든 정점 쌍 간의 최단 경로르 구하는 것으로 플로이드 - 워샬 알고리즘 이용

'''
다익스트라 알고리즘
- 시작 정점에서 거리가 최소인 정점부터 선택해 나가면서 최단 경로를 구하는 방식
- 탐욕 기법을 이용한 알고리즘으로 최소 신장트리를 구하는 프림 알고리즘과 유사
- 시작 정점에서 끝 정점까지 최단 경로에 정점 x가 존재

# 시작점에서 최단 경로를 찾은 정점들의집합(S)를 관리
- 최소 S = [r], d[r] = 0, d[v] = INF
- 최단 경로를 찾은 정점을 하나씩 집합 S에 추가
- 집합 에스에 포함되지 않은 정점들 중에 출발점에 가장 가까운 정점 선택
'''

# D: 출발접에서 각 정점까지 최단 경로 가중치 합을 저장
# P: 최단 경로 트리 저장
INF = float('inf')
N = 10
def Dijkstra(G, r): # 그래프, 시작 정점
  # 인접 정점들은 가중치 값이 설정되고
  # 인접하지 않은 정점에 대해서는 아주 큰 값을 설정
  D = [INF] * N
  P = [None] * N
  visited = [False] * N
  D[r] = 0
  # 이미 선택된 정점, 지금 선택된 정점, D값이 생신되는 지점
  # 이미 최소값을 찾은 쪽은 가지 않는다.
  for _ in range(N):
    minIndex = -1
    min = INF
    for i in range(N):
      if not visited[i] and D[i] < min:
        min = D[i]
        minIndex = i
    visited[minIndex] = True

    for v, val in G[minIndex]:
      if not visited[v] and D[minIndex] + val < D[v]:
        D[v] = D[minIndex] + val
        P[v] = minIndex

# 음의 가중치가 있는 경우
# 시작점으로 선택 --> 거리 0으로 하고 거리에 포함
# 다익스트라 알고리즘은 이미 선택된 정점들은 제외
# 음의 가중치에 의해 X에 대한 거리값 갱신되어야 한다.
# 음의 가중치가 포함된 그래프에 대해 제대로 동작하지 않는다.

# 벨만포드
# 가중치의 합이 음인 사이클은 허용하지 않음
# 출발점에서 각 정점까지 간선 하나로 구성된 경로만 구성해서 최단 경로를 구함
# 최대 간선 두개까지 고려해서 최단 경로를 구해나가서 최대 간선 n-1개까지 고려한 경로들에서 최단 경로를 구함(n은 정점의 개수)
# - 동적 계획법 적용
# 다익스트라에 비해 많은 시간 소요